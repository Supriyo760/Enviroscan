# -*- coding: utf-8 -*-
"""Supriyo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ge-7k3tuhOvAs1OkM0m95b5EmNA9Jv43

data set of loader
"""


import pandas as pd
import requests
import osmnx as ox
def fetch_openaq_data(city, params):
  url = f"https://api.openaq.org/v2/measurements?city={city}"
  response = response.get(url, params= params)
  data = response.json()['results']
  return pd.DataFrame(data)

def fetch_weather_data(lat, lon, api_key):
  url = f"https://api.openweathermap.org/data/2.5/weather"
  params = {'lat': lat, 'lon': lon, 'appid': api_key}
  response = requests.get(url, params=params)
  return response.json()

def get_location_features(lat, lon, dist= 1000):
  G= ox.graph_from_point((lat, lon), dist= dist, network_type= 'drive')
  roads= ox.geometries.geometries_from_point((lat, lon), tags= {'highway': True}, dist=dist)
  factories= ox.geometries.geometries_from_point((lat, lon), tags= {'landuse': 'industrial'}, dist= dist)
  return {'roads': roads, 'factories': factories}

"""data cleaning

"""

def clean_pollution_data(df):
  df = df.drop_duplicates()
  df = df.dropna(subset=['value', 'coordinates.latitude', 'coordinates.longitude'])
  df['value']= pd.to_numeric(df['value'])
  df['timestamp']= pd.to_datetime(df['date']['utc'])
  #impute missing values
  df= df.fillna(df.mean())
  return df
def features_engineering(df):
  for col in['value']:
    df[col]= (df[col]-df[col].mean())/ df[col].std()
    df['hour']= df['timestamp'].dt.hour
    df['dayofweek']= df['timestamp'].dt.dayofweek
    df['month']= df['timestamp'].dt.month
    return df

"""SOURCE LABELLING AND SIMULATION

"""

def label_sources(df):
  df['source']= 'Unknown'
  df.loc[(df['near_main_road']==1)&(df['NO2']>40), 'source'] = 'Vehicular'
  df.loc[(df['near_factory']==1)&(df['SO2']>20), 'source'] = 'Industrial'
  df.loc[(df['near_farmland']==1)&(df['season']=='Dry')& (df['PM2.5']>70), 'source'] = 'Agricultural'
  return df

"""Model Training and Source Prediction"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.metrics import accuracy_score, classification_report

def train_predict_model(df):
  features= ['PM2.5','NO2','SO2','CO','roads_proximity','factories_proximity','temperature','humidity','hour','dayofweek','month']
  x=df[features]
  y=df['source']
  x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, stratify=y)
  cif= RandomForestClassifier()
  param_grid= {'n_estimators': [50, 100], 'max_depth': [5,10,None]}
  grid= GridSearchCV(cif, param_grid)
  grid.fit(x_train, y_train)
  y_pred= grid.predict(x_test)
  print(classification_report(y_test, y_pred))
  return grid.best_estimator_

"""Geospatial Mapping and Visualization"""

import folium

def plot_heatmap(df):
    m = folium.Map(location=[df['latitude'].mean(), df['longitude'].mean()], zoom_start=12)
    for _, row in df.iterrows():
        folium.Circle(
            location=[row['latitude'], row['longitude']],
            radius=50,
            color="red" if row['source'] == "Industrial" else "blue",
            fill=True
        ).add_to(m)
    return m

"""real-time dashboard and alerts(streamlit)"""






# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# 
# st.set_page_config(page_title="Pollution Source Identifier")
# 
# st.title(" AI-Powered Pollution Source Identifier")
# 
# city = st.text_input("Enter a city name", placeholder="e.g., Delhi")
# 
#  if st.button("Analyze"):
#     if city.strip() == "":
#         st.warning(" Please enter a valid city name.")
#     else:
#         st.success(f"Analyzing pollution sources for: {city}")
#         st.markdown(f"""
#         ###  AI Analysis Results for **{city}** (Simulated)
#         - **Main Pollutants:** PM2.5, NOx, SO2
#         - **Likely Sources:**
#             -  Vehicle emissions
#             - Industrial activity
#             -  Biomass/garbage burning
#         - **Air Quality Index (AQI):** 185 (Unhealthy)
#         - **Recommendation:** Limit outdoor activity. Use masks. Air purifiers recommended indoors.
#         """)

# ‚úÖ Step 1: Install required packages


# ‚úÖ Step 2: Import necessary libraries
from pyngrok import ngrok
import time
import os

# ‚úÖ Step 3: Export your ngrok authtoken (this sets an environment variable)
os.environ["NGROK_AUTHTOKEN"] =  "32SlneBxn5rvtKCuoIMTuDOkASV_5YnDn6RerRqkhVmkYQjMv"

# ‚úÖ Step 4: Authenticate pyngrok using the exported token
ngrok.set_auth_token(os.environ["NGROK_AUTHTOKEN"])

# ‚úÖ Step 5: Kill any existing Streamlit process


# ‚úÖ Step 6: Define your Streamlit app code
app_code = '''
import streamlit as st

st.set_page_config(page_title="Streamlit via ngrok", page_icon="üîó")
st.title("üöÄ Hello from Streamlit!")
st.write("This Streamlit app is running through an ngrok tunnel.")
'''

# ‚úÖ Step 7: Write app code to a file
with open("app.py", "w") as f:
    f.write(app_code)

# ‚úÖ Step 8: Start the Streamlit app in the background


# ‚úÖ Step 9: Wait a few seconds for the app to boot
time.sleep(5)

# ‚úÖ Step 10: Open an ngrok tunnel to port 8501

# ‚úÖ Step 11: Print the public URL


# 1Ô∏è‚É£ Install required packages


# 2Ô∏è‚É£ Imports
from pyngrok import ngrok
import time
import os

# 3Ô∏è‚É£ Kill any existing Streamlit instance (clean slate)


# 4Ô∏è‚É£ Set your ngrok authtoken here (replace with your real token)
NGROK_AUTHTOKEN = "32SlneBxn5rvtKCuoIMTuDOkASV_5YnDn6RerRqkhVmkYQjMv"
ngrok.set_auth_token(NGROK_AUTHTOKEN)

# 5Ô∏è‚É£ Write your Streamlit app code
app_code = '''
import streamlit as st

st.set_page_config(page_title="Streamlit + ngrok", page_icon="üöÄ")
st.title("üöÄ Hello from Streamlit!")
st.write("This app runs inside Colab and is accessible via ngrok tunnel.")
'''

with open("app.py", "w") as f:
    f.write(app_code)

# 6Ô∏è‚É£ Start Streamlit app in background


# 7Ô∏è‚É£ Wait for Streamlit server to start
time.sleep(5)

# 8Ô∏è‚É£ Open ngrok tunnel on port 8501


# 9Ô∏è‚É£ Display the public URL


# Start Streamlit in background


# Give more time for Streamlit to start (e.g., 15 seconds)
import time
time.sleep(15)

# Then create ngrok tunnel
from pyngrok import ngrok
ngrok.set_auth_token("32SlneBxn5rvtKCuoIMTuDOkASV_5YnDn6RerRqkhVmkYQjMv")

# Install required packages (run once)


import os
import time
import subprocess
from pyngrok import ngrok

# Set your ngrok auth token (replace with your actual token)
NGROK_AUTH_TOKEN = "YOUR_NGROK_AUTH_TOKEN_HERE"
ngrok.set_auth_token(NGROK_AUTH_TOKEN)

# Write a simple Streamlit app
app_code = """
import streamlit as st

st.title("üöÄ EnviroScan Pollution Source Identifier")

city = st.text_input("Enter a city name", "Delhi")
if st.button("Analyze"):
    if not city.strip():
        st.warning("Please enter a valid city name.")
    else:
        st.success(f"Analyzing pollution sources for: {city}")
        st.markdown('''
        ### AI Analysis Results for **{city}** (Simulated)
        - **Main Pollutants:** PM2.5, NOx, SO2
        - **Likely Sources:**
          - Vehicle emissions
          - Industrial activity
          - Biomass/garbage burning
        - **Air Quality Index (AQI):** 185 (Unhealthy)
        - **Recommendation:** Limit outdoor activity. Use masks. Air purifiers recommended indoors.
        '''.format(city=city))
"""

with open("app.py", "w") as f:
    f.write(app_code)

# Kill previous Streamlit instances
subprocess.run(["pkill", "-f", "streamlit"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

# Disconnect any existing ngrok tunnels to avoid free-tier limits
for tunnel in ngrok.get_tunnels():
    ngrok.disconnect(tunnel.public_url)

# Start Streamlit app in the background
streamlit_process = subprocess.Popen(["streamlit", "run", "app.py"])

# Wait for Streamlit server to start
time.sleep(15)  # Increase if needed

# Open ngrok tunnel to port 8501
public_url = ngrok.connect(8501)
print(f"üåê Your Streamlit app is live at: {public_url}")

# Keep process alive to maintain server & tunnel
try:
    streamlit_process.wait()
except KeyboardInterrupt:
    streamlit_process.terminate()
    ngrok.disconnect(public_url)
    print("Terminated Streamlit and ngrok tunnel.")

